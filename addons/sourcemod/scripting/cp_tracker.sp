/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <tf2>

#pragma semicolon 1

#define MAX_CONTROL_POINTS 9

enum ControlPoint
{
	ControlPoint_Entity,
	bool:ControlPoint_Unlocked,
	TFTeam:ControlPoint_Owner
}

new TFGameType
{
	TFGameType_CTF,
	TFGameType_5CP,
	TFGameType_ADCP,
	TFGameType_TC,
	TFGameType_PL,
	TFGameType_PLR,
	TFGameType_Arena,
	TFGameType_KOTH,
	TFGameType_SD,
	TFGameType_MvM,
	
}

new cpInfo[MAX_CONTROL_POINTS][ControlPoint];

new bool:multiRound;
new Handle:g_Kv_RoundStrings;

public Plugin:myinfo = 
{
	name = "Control Point Tracker",
	author = "Powerlord",
	description = "<- Description ->",
	version = "1.0",
	url = "<- URL ->"
}

public OnPluginStart()
{
	HookEntityOutput("team_control_point", "OnUnlocked", Hook_OnUnlocked);
	HookEntityOutput("team_control_point", "OnRoundStartOwnedByTeam1", Hook_OnOwnerChangedToTeam1);
	HookEntityOutput("team_control_point", "OnRoundStartOwnedByTeam2", Hook_OnOwnerChangedToTeam2);
	HookEntityOutput("team_control_point", "OnOwnerChangedToTeam1", Hook_OnOwnerChangedToTeam1);
	HookEntityOutput("team_control_point", "OnOwnerChangedToTeam2", Hook_OnOwnerChangedToTeam2);
	HookEntityOutput("team_control_point", "OnCapReset", Hook_OnCapReset);
	
}

public OnMapStart()
{
	multiRound = false;
	CloseHandle(g_Kv_RoundStrings);
	g_Kv_RoundStrings = INVALID_HANDLE;
}

public Action:Cmd_PrintCPStatus(client, args)
{
	
}

public OnEntityCreated(entity, const String:classname[])
{
	if (StrEqual(classname, "team_control_point"))
	{
		SDKHook(entity, SDKHook_SpawnPost, OnCpSpawned);
	}
	else if (StrEqual(classname, "team_control_point_round"))
	{
		SDKHook(entity, SDKHook_SpawnPost, OnRoundSpawned);
	}
}

public OnRoundSpawned(entity)
{
	if (!IsValidEntity(entity))
	{
		return;
	}
	
	if (g_Kv_RoundStrings == INVALID_HANDLE)
	{
		g_Kv_RoundStrings = CreateKeyValues("Rounds");
	}
	
	KvRewind(g_Kv_RoundStrings);
	
	new count = KvGetNum(g_Kv_RoundStrings, "count", 0) + 1;
	
	new String:strEntity[6];
	KvJumpToKey(g_Kv_RoundStrings, strEntity, true);
	IntToString(entity, strEntity, sizeof(strEntity));
	new String:roundName[64];
	GetEntPropString(entity, Prop_Data, "m_iName", roundName, sizeof(roundName));
	KvSetString(g_Kv_RoundStrings, "name", roundName);
	KvSetNum(g_Kv_RoundStrings, "priority", GetEntProp(entity, Prop_Data, "m_nPriority"));
}

public OnCpSpawned(entity)
{
	CpSetup(entity);
}

public OnEntityDestroyed(entity)
{
	CpCleanup(entity);
	
}

GetIndexOfCp(entity)
{
	if (entity <= 0 || entity > GetMaxEntities() || !IsValidEntity(entity))
	{
		return -1;
	}
	
	for (new i = 0; i < MAX_CONTROL_POINTS; ++i)
	{
		new cpEnt = EntRefToEntIndex(cpInfo[i][ControlPoint_Entity]);
		if (entity == cpEnt)
		{
			return i;
		}
	}
	
	return -1;
}

CpSetup(entity)
{
	new index = GetEntProp(entity, Prop_Data, "m_iPointIndex");
	cpInfo[index][ControlPoint_Entity] = EntIndexToEntRef(entity);
	cpInfo[index][ControlPoint_Unlocked] = bool:GetEntProp(entity, Prop_Data, "m_bLocked");
	cpInfo[index][ControlPoint_Owner] = TFTeam:GetEntProp(entity, Prop_Data, "m_iDefaultOwner");
}

CpCleanup(entity)
{
	new index = GetIndexOfCp(entity);
	if (index > -1)
	{
		cpInfo[index][ControlPoint_Entity] = 0;
		cpInfo[index][ControlPoint_Unlocked] = false;
		cpInfo[index][ControlPoint_Owner] = TFTeam_Unassigned;
	}
}

public Hook_OnUnlocked(const String:output[], caller, activator, Float:delay)
{
	new index = GetIndexOfCp(caller);
	
	if (index == -1)
	{
		return;
	}

	cpInfo[index][ControlPoint_Unlocked] = true;
}

public Hook_OnOwnerChangedToTeam1(const String:output[], caller, activator, Float:delay)
{
	new index = GetIndexOfCp(caller);
	
	if (index == -1)
	{
		return;
	}
	
	cpInfo[index][ControlPoint_Owner] = TFTeam_Red;
}

public Hook_OnOwnerChangedToTeam2(const String:output[], caller, activator, Float:delay)
{
	new index = GetIndexOfCp(caller);
	
	if (index == -1)
	{
		return;
	}

	cpInfo[index][ControlPoint_Owner] = TFTeam_Red;
}

public Hook_OnCapReset(const String:output[], caller, activator, Float:delay)
{
	new index = GetIndexOfCp(caller);
	
	if (index == -1)
	{
		return;
	}

	cpInfo[index][ControlPoint_Owner] = TFTeam_Unassigned;
}
